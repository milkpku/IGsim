/* This file is part of IGsim, a simple c++ simulation library.
 * 
 * Copyright (C) 2016 Like Ma <milkpku@gmail.com>
 * 
 * This Source Code Form is subject to the terms of the Mozilla Public License 
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can 
 * obtain one at http://mozilla.org/MPL/2.0/.
 * This should *NOT* be contained in a IGSIM_*_H ifdef, since it may be defined
 * differently based on when it is included
 */

#include "writeVTK.h"

#include <Eigen/Dense>

#include <boost/format.hpp>

#include <iostream>
#include <string>
#include <fstream>

template <typename DerivedV, typename DerivedT> 
IGSIM_INLINE void sim::writeVTK(
  const std::string& filename,
  const Eigen::PlainObjectBase<DerivedV>& V,
  const Eigen::PlainObjectBase<DerivedT>& T)
{
  std::ofstream out(filename, std::ofstream::out);
  if (!out.is_open())
  {
    std::cerr << boost::format("fail to open file %s\n") % filename;
    return;
  }
  writeVTK(out, V, T);
  out.close();
}

template <typename DerivedV, typename DerivedT, typename DerivedVi>
IGSIM_INLINE void sim::writeVTK(
  const std::string& filename,
  const Eigen::PlainObjectBase<DerivedV>& V,
  const Eigen::PlainObjectBase<DerivedT>& T,
  const VTK_TYPE& info_type,
  const Eigen::PlainObjectBase<DerivedVi>& V_info)
{
  std::ofstream out(filename, std::ofstream::out);
  if (!out.is_open())
  {
    std::cerr << boost::format("fail to open file %s\n") % filename;
    return;
  }
  writeVTK(out, V, T);
  writeVTK(out, V.rows(), T.rows(), true, "attr", info_type, V_info);
  out.close();
}

template <typename DerivedV, typename DerivedT>
IGSIM_INLINE void sim::writeVTK(
  std::ofstream& fout,
  const Eigen::PlainObjectBase<DerivedV>& V,
  const Eigen::PlainObjectBase<DerivedT>& T)
{
  assert(V.cols() == 3 && "vertices dim should be 3");
  assert(T.cols() == 4 && "tetrahedron dim should be 4");

  /* vtk headers */
  fout << "# vtk DataFile Version 2.0\n";
  fout << "generated by IGsim/writeVTK\n";
  fout << "ASCII\n";
  fout << "DATASET UNSTRUCTURED_GRID\n";

  /* vertices coordinate */
  fout << boost::format("POINTS %d FLOAT\n") % V.rows();
  for(int i = 0; i < V.rows(); i++)
  {
    auto v = V.row(i);
    fout << boost::format("%f %f %f\n") % v(0) % v(1) % v(2); 
  }

  /* tetrahedron connectivity */
  fout << boost::format("CELLS %d %d\n") % T.rows() % (T.size() + T.rows());
  for(int i = 0; i < T.rows(); i++)
  {
    auto t = T.row(i);
    fout << boost::format("4 %d %d %d %d\n") % t(0) % t(1) % t(2) % t(3); 
  }
  fout << boost::format("CELL_TYPES %d\n") % T.rows();
  for(int i = 0; i < T.rows(); i++)
    fout << "10\n"; /* VTK_TETRA (10) */
}

template <typename DerivedVi>
IGSIM_INLINE void sim::writeVTK(
  std::ofstream& fout,
  const int V_size,
  const int T_size,
  const bool header,
  const std::string name,
  const VTK_TYPE& info_type,
  const Eigen::PlainObjectBase<DerivedVi>& V_info)
{
  if (header)
  {
    if (V_info.rows() == V_size)
    {
      fout << boost::format("POINT_DATA %d\n") % V_size;
    }
    else if (V_info.rows() == T_size)
    {
      fout << boost::format("CELL_DATA %d\n") % T_size;
    }
    else
    {
      assert(false && "no matching object for attribute");
    }
  }
  
  switch (info_type)
  {
    case VTK_SCALAR:
      assert(V_info.cols() == 1 && "scalar should be 1 dim");
      fout << boost::format("SCALARS %s FLOAT\n") % name;
      fout << "LOOKUP_TABLE default\n";
      for(int i = 0; i < V_info.rows(); i++)
        fout << boost::format("%f\n") % V_info(i);
      break;
    case VTK_COLOR:
      assert(false && "not implemented yet");
      break;
    case VTK_VECTOR:
      assert(V_info.cols() == 3 && "scalar should be 1 dim");
      fout << boost::format("VECTORS %s float\n") % name;
      for(int i = 0; i < V_info.rows(); i++)
      {
        auto v = V_info.row(i);
        fout << boost::format("%f %f %f\n") % v(0) % v(1) % v(2);
      }
      break;
    case VTK_TEXTURE:
      assert(false && "not implemented yet");
      break;
  }
}
